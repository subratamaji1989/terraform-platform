version: 0.2

# variables:
#     # The only variable needed from the CodeBuild project. It points to the pipeline's configuration file.
#   PIPELINE_VARS_PATH: "app-ovr-infra/aws/${ENV}/pipeline-vars.yml"

phases:
  install:
    runtime-versions:
      python: 3.9
      nodejs: 16
    commands:
      - |
        echo "==> [INSTALL] Installing yq (standalone)..."
        if ! command -v yq &>/dev/null; then
          wget https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -O /usr/local/bin/yq
          chmod +x /usr/local/bin/yq
        fi

      - echo "==> [INSTALL] Loading pipeline variables from ${PIPELINE_VARS_PATH}..."
      # Use yq to parse the YAML file and export its keys as environment variables.
      - pip install --upgrade pip -q pyyaml awscli
      - eval "$(yq e '.pipeline-parameters | to_entries | .[] | "export " + .key + "=" + (.value | @sh)' ${PIPELINE_VARS_PATH})"
      - |
        # Verify that all essential variables have been loaded.
        for var in PIPELINE_STAGE COMPOSITION_PATH TF_VERSION; do
          if [ -z "${!var}" ]; then
            echo "FATAL: Essential pipeline variable '$var' is missing or empty. Check ${PIPELINE_VARS_PATH}."
            exit 1
          fi
        done

        echo "--> Successfully loaded and exported pipeline variables:"
        echo "    PIPELINE_STAGE: ${PIPELINE_STAGE}"
        echo "    COMPOSITION_PATH: ${COMPOSITION_PATH}"
        echo "    TF_VERSION: ${TF_VERSION}"
      - echo "==> [INSTALL] Installing base dependencies..."
      - set -e # Exit immediately if a command exits with a non-zero status.
      - npm install -g ajv-cli

      - |
        echo "==> [INSTALL] Installing Terraform v${TF_VERSION}..."
        # Only install if the correct version isn't already present to save time.
        if ! terraform version 2>/dev/null | grep -q "Terraform v${TF_VERSION}"; then
          wget "https://releases.hashicorp.com/terraform/${TF_VERSION}/terraform_${TF_VERSION}_linux_amd64.zip" -O /tmp/tf.zip
          unzip -o /tmp/tf.zip -d /usr/local/bin
          rm /tmp/tf.zip
        fi
        terraform -v

      - |
        echo "==> [INSTALL] Installing DevSecOps tools..."
        # Securely install tflint by downloading and then executing, not piping to bash
        if ! command -v tflint &>/dev/null; then
          curl -sL https://raw.githubusercontent.com/terraform-linters/tflint/master/install_linux.sh > /tmp/install_tflint.sh
          chmod +x /tmp/install_tflint.sh && /tmp/install_tflint.sh && rm /tmp/install_tflint.sh
        fi
        if ! command -v tfsec &>/dev/null; then
          curl -L "https://github.com/aquasecurity/tfsec/releases/latest/download/tfsec-linux-amd64" -o /usr/local/bin/tfsec && chmod +x /usr/local/bin/tfsec
        fi

  build:
    commands:
      - |
        # Store the absolute path to the project root.
        PROJECT_ROOT=$(pwd)
        # Define an absolute path for the generated tfvars file to avoid path issues after changing directories.
        TFVARS_FILE="${PROJECT_ROOT}/generated/all.tfvars.json"

        # Make all paths absolute to prevent issues after changing directories.
        COMPOSITION_PATH="${PROJECT_ROOT}/${COMPOSITION_PATH}"
        SCHEMA_PATH="${PROJECT_ROOT}/${SCHEMA_PATH}"
        TOOLS_PATH="${PROJECT_ROOT}/aws/tools"
        VARS_PATH="${PROJECT_ROOT}/../${VARS_PATH}"
        BACKEND_CONFIG_PATH="${PROJECT_ROOT}/../${BACKEND_CONFIG_PATH}"
        

        # set -eu # Exit on error and on unset variables
        # ===================================================================================
        # ==                            VALIDATE STAGE                                     ==
        # ===================================================================================

        if [ "$PIPELINE_STAGE" = "VALIDATE" ] || [ "$PIPELINE_STAGE" = "ALL" ]; then
          (
            echo "==> [BUILD] Executing VALIDATE stage..."

            echo "--> Validating YAML against JSON schema..."
            if [ -n "${SCHEMA_PATH:-}" ] && [ -n "${MAIN_YAML_FILE:-}" ]; then
              ajv validate -s "$SCHEMA_PATH" -d "${VARS_PATH}/${MAIN_YAML_FILE}"
            else
              echo "--> Skipping schema validation: SCHEMA_PATH or MAIN_YAML_FILE not set."
            fi

            echo "--> Merging YAML files into all.tfvars.json..."
            mkdir -p generated
            python ${TOOLS_PATH}/yaml2tfvars.py "$VARS_PATH" "${TFVARS_FILE}"

            echo "--> Running Terraform dry-run and security scans in ${COMPOSITION_PATH}..."
            cd "$COMPOSITION_PATH"
            terraform init -backend=false
            terraform validate
            # Let the plan fail if there are errors. The 'set -e' will catch it.
            terraform plan -var-file="${TFVARS_FILE}" -out=precheck.tfplan
            # Only generate JSON if plan was successful
            terraform show -json precheck.tfplan > precheck.json

            echo "--> Running DevSecOps Scanners..."
            tflint --force
            tfsec .
            # checkov -d . --quiet
            # conftest test precheck.json --policy ../../policies/conftest
          )
        fi

        # ===================================================================================
        # ==                               PLAN STAGE                                      ==
        # ===================================================================================
        if [ "$PIPELINE_STAGE" = "PLAN" ] || [ "$PIPELINE_STAGE" = "ALL" ]; then
          (
            echo "==> [BUILD] Executing PLAN stage..."
            echo "--> Initializing Terraform with backend config: ${BACKEND_CONFIG_PATH}"
            cd "$COMPOSITION_PATH"
            terraform init -backend-config="${BACKEND_CONFIG_PATH}" -reconfigure

            echo "--> Generating Terraform plan..."
            terraform plan -var-file="${TFVARS_FILE}" -out=tfplan
            terraform show -json tfplan > plan.json
          )
        fi

        # ===================================================================================
        # ==                               APPLY STAGE                                     ==
        # ===================================================================================
        if [ "$PIPELINE_STAGE" = "APPLY" ] || [ "$PIPELINE_STAGE" = "ALL" ]; then
          (
            echo "==> [BUILD] Executing APPLY stage..."
            echo "--> Initializing Terraform with backend config: ${BACKEND_CONFIG_PATH}"
            cd "$COMPOSITION_PATH"
            # The 'tfplan' artifact is automatically downloaded by CodePipeline into the correct directory
            terraform init -backend-config="${BACKEND_CONFIG_PATH}" -reconfigure
            echo "--> Applying Terraform plan..."
            terraform apply -input=false tfplan
          )
        fi

        # ===================================================================================
        # ==                           POST-VALIDATE STAGE                                 ==
        # ===================================================================================
        if [ "$PIPELINE_STAGE" = "POST_VALIDATE" ] || [ "$PIPELINE_STAGE" = "ALL" ]; then
          echo "==> [BUILD] Executing POST-VALIDATE stage..."
          echo "--> Running AWS post-deployment checks..."
          # Example: Check instance state using values from the generated variables artifact
          INSTANCE_NAME=$(yq -r '.tags.Name' "${TFVARS_FILE}")
          aws ec2 describe-instances --filters "Name=tag:Name,Values=${INSTANCE_NAME}" --query "Reservations[].Instances[].State.Name"
          # Example: Notify via SNS using a topic ARN from Parameter Store
          # aws sns publish --topic-arn "${SNS_TOPIC_ARN}" --message "Deployment for ${INSTANCE_NAME} completed successfully."
        fi
      

artifacts:
  files:
    # This generated file contains all merged variables and is needed by the PLAN stage.
    - 'generated/all.tfvars.json'
    # The pre-check plan file, used for security scanning and validation. Not used by subsequent stages.
    - '${COMPOSITION_PATH}/precheck.tfplan'
    - '${COMPOSITION_PATH}/precheck.json'
    # The final plan file, which is the primary artifact for the APPLY stage.
    - '${COMPOSITION_PATH}/tfplan'
    # The JSON representation of the final plan, useful for post-processing or manual review.
    - '${COMPOSITION_PATH}/plan.json'
  discard-paths: yes