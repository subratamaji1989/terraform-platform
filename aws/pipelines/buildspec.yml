version: 0.2

# variables:
#     # The only variable needed from the CodeBuild project. It points to the pipeline's configuration file.
#   PIPELINE_VARS_PATH: "app-ovr-infra/aws/${ENV}/pipeline-vars.yml"

phases:
  install:
    runtime-versions:
      python: 3.9
      nodejs: 16
    commands:
      - |
        set -euo pipefail # Fail fast on any errors during setup

        echo "==> [SETUP] Configuring cache and PATH..."
        mkdir -p .local/bin
        export PATH=$(pwd)/.local/bin:$PATH

        echo "==> [INSTALL] Installing yq..."
        YQ_VERSION="v4.40.5"
        YQ_SHA256="9323c8901842722a163b538656540e5bd5424a4c195914a57794e284a48d132a"
        if ! command -v yq &>/dev/null; then
          echo "--> yq not found in cache, downloading..."
          wget "https://github.com/mikefarah/yq/releases/download/${YQ_VERSION}/yq_linux_amd64" -O .local/bin/yq
          echo "${YQ_SHA256}  .local/bin/yq" | sha256sum -c -
          chmod +x .local/bin/yq
        fi
        yq --version

        echo "==> [INSTALL] Installing base dependencies (pip, npm)..."
        pip install --upgrade pip -q pyyaml awscli
        npm install -g ajv-cli

        echo "==> [INSTALL] Loading pipeline variables from ${PIPELINE_VARS_PATH}..."
        eval "$(yq e '.pipeline-parameters | to_entries | .[] | "export " + .key + "=" + (.value | @sh)' ${PIPELINE_VARS_PATH})"
        
        echo "==> [INSTALL] Installing Terraform v${TF_VERSION}..."
        declare -A TF_CHECKSUMS=(
          ["1.6.6"]="6c3992f231d49932138093f48f0e0a33a01383c5a730b32c6b0a803452b4b353"
        )
        TF_SHA256="${TF_CHECKSUMS[${TF_VERSION}]}"

        # Only install if the correct version isn't already present to save time.
        if ! terraform version 2>/dev/null | grep -q "Terraform v${TF_VERSION}"; then
          if [ -z "${TF_SHA256}" ]; then
            echo "FATAL: Checksum for Terraform v${TF_VERSION} is not defined. Please add it to the buildspec."
            exit 1
          fi
          wget "https://releases.hashicorp.com/terraform/${TF_VERSION}/terraform_${TF_VERSION}_linux_amd64.zip" -O .local/terraform.zip
          echo "${TF_SHA256}  .local/terraform.zip" | sha256sum -c -
          unzip -o .local/terraform.zip -d .local/bin
          rm .local/terraform.zip
        fi
        terraform -v

        echo "==> [INSTALL] Installing DevSecOps tools with explicit versions..."
        TFLINT_VERSION="v0.50.3"
        TFSEC_VERSION="v1.28.1"
        if ! command -v tflint &>/dev/null; then
          echo "--> tflint not found in cache, downloading..."
          # The install script puts it in /usr/local/bin, which is not cached. We move it.
          curl -s https://raw.githubusercontent.com/terraform-linters/tflint/master/install_linux.sh | bash -s -- "${TFLINT_VERSION}"
          mv /usr/local/bin/tflint .local/bin/tflint
        fi

        if ! command -v tfsec &>/dev/null; then
          echo "--> tfsec not found in cache, downloading..."
          curl -L "https://github.com/aquasecurity/tfsec/releases/download/${TFSEC_VERSION}/tfsec-linux-amd64" -o .local/bin/tfsec && chmod +x .local/bin/tfsec
        fi

        # pip install checkov=="${CHECKOV_VERSION:-3.2.79}" conftest -q
        

  build:
    commands:
      - |
        echo "==> [SETUP] Re-exporting PATH for build phase..."
        export PATH=$(pwd)/.local/bin:$PATH

        echo "==> [SETUP] Re-exporting variables for build phase..."
        # The `eval` only lasts for the `install` phase, so we must run it again here.
        # This is safe because PIPELINE_VARS_PATH is a system-provided environment variable.
        eval "$(yq e '.pipeline-parameters | to_entries | .[] | "export " + .key + "=" + (.value | @sh)' ${PIPELINE_VARS_PATH})"

        # ===================================================================================
        # ==                              COMMON SETUP                                     ==
        # ===================================================================================
        echo "==> [BUILD] Performing common setup..."

        # Store the absolute path to the project root.
        PROJECT_ROOT=$(pwd)
        # Define an absolute path for the generated tfvars file to avoid path issues after changing directories.
        TFVARS_FILE="${PROJECT_ROOT}/generated/all.tfvars.json"

        echo "--> Making all paths absolute..."
        COMPOSITION_PATH="${PROJECT_ROOT}/${COMPOSITION_PATH}"
        SCHEMAS_DIR_PATH="${PROJECT_ROOT}/${SCHEMAS_DIR_PATH}"
        TOOLS_PATH="${PROJECT_ROOT}/aws/tools"
        VARS_PATH="${PROJECT_ROOT}/../${VARS_PATH}"
        BACKEND_CONFIG_PATH="${PROJECT_ROOT}/../${BACKEND_CONFIG_PATH}"

        echo "--> Verifying existence of composition path: ${COMPOSITION_PATH}"
        if [ ! -d "$COMPOSITION_PATH" ]; then
            echo "FATAL: The specified COMPOSITION_PATH does not exist or is not a directory."
            echo "       Please check the CLOUD and STACK_NAME variables in your pipeline-vars.yml file."
            exit 1
        fi

        echo "--> Merging variable YAML files into ${TFVARS_FILE}..."
        mkdir -p "$(dirname "${TFVARS_FILE}")"
        python3 "${TOOLS_PATH}/yaml2tfvars.py" "$VARS_PATH" "${TFVARS_FILE}"

        echo "--> Changing to composition directory: ${COMPOSITION_PATH}"
        cd "$COMPOSITION_PATH"

        echo "--> Initializing Terraform for validation and dry-runs..."
        terraform init -backend=false

        # ===================================================================================
        # ==                            VALIDATE STAGE                                     ==
        # ===================================================================================
        if [ "$PIPELINE_STAGE" = "VALIDATE" ] || [ "$PIPELINE_STAGE" = "ALL" ]; then
          (
            echo "==> [BUILD] Executing VALIDATE stage..."

            # Define a function to validate all YAML files in a directory against their corresponding schemas.
            validate_yaml_files() {
              local vars_dir="$1"
              local schemas_dir="$2"

              echo "--> Validating all YAML files in '${vars_dir}' against schemas in '${schemas_dir}'..."

              if [ ! -d "$vars_dir" ]; then
                  echo "--> WARNING: Variables directory '$vars_dir' not found. Skipping schema validation."
                  return
              fi

              # Use find to handle cases with no .yaml files gracefully
              find "$vars_dir" -name "*.yaml" -o -name "*.yml" | while read -r yaml_file; do
                  local filename
                  filename=$(basename "${yaml_file}")
                  local schema_name="${filename%.*}.schema.json" # e.g., vm.yaml -> vm.schema.json
                  local schema_file="${schemas_dir}/${schema_name}"

                  [ -f "$schema_file" ] && ajv validate -s "$schema_file" -d "$yaml_file" || echo "--> INFO: No schema found for '${filename}', skipping validation."
              done
            }
            validate_yaml_files "$VARS_PATH" "$SCHEMAS_DIR_PATH"

            echo "--> Running Terraform dry-run and security scans in ${COMPOSITION_PATH}..."
            terraform validate
            # Let the plan fail if there are errors. The 'set -e' will catch it.
            terraform plan -var-file="${TFVARS_FILE}" -out=precheck.tfplan
            # Only generate JSON if plan was successful
            terraform show -json precheck.tfplan > precheck.plan.json

            echo "--> Running DevSecOps Scanners..."
            tflint --force
            tfsec .
            # checkov --directory . --quiet
            # # Find all conftest policies and run them against the plan
            # find "${PROJECT_ROOT}/policies/conftest" -name '*.rego' -print0 | xargs -0 -I {} conftest test precheck.plan.json --policy {} --no-color
          )
        fi

        # ===================================================================================
        # ==                               PLAN STAGE                                      ==
        # ===================================================================================
        if [ "$PIPELINE_STAGE" = "PLAN" ] || [ "$PIPELINE_STAGE" = "ALL" ]; then
          (
            echo "==> [BUILD] Executing PLAN stage..."
            echo "--> Initializing Terraform with backend config: ${BACKEND_CONFIG_PATH}"
            terraform init -backend-config="${BACKEND_CONFIG_PATH}" -reconfigure -input=false

            echo "--> Generating Terraform plan..."
            terraform plan -var-file="${TFVARS_FILE}" -out=tfplan
            terraform show -json tfplan > plan.json # For auditing and change analysis
          )
        fi

        # ===================================================================================
        # ==                               APPLY STAGE                                     ==
        # ===================================================================================
        if [ "$PIPELINE_STAGE" = "APPLY" ] || [ "$PIPELINE_STAGE" = "ALL" ]; then
          (
            echo "==> [BUILD] Executing APPLY stage..."
            echo "--> Initializing Terraform with backend config: ${BACKEND_CONFIG_PATH}"
            # The 'tfplan' artifact is automatically downloaded by CodePipeline into the correct directory
            terraform init -backend-config="${BACKEND_CONFIG_PATH}" -reconfigure -input=false
            echo "--> Applying Terraform plan..."
            terraform apply -input=false "tfplan"
          )
        fi

        # ===================================================================================
        # ==                           POST-VALIDATE STAGE                                 ==
        # ===================================================================================
        if [ "$PIPELINE_STAGE" = "POST_VALIDATE" ] || [ "$PIPELINE_STAGE" = "ALL" ]; then
          echo "==> [BUILD] Executing POST-VALIDATE stage..."
          echo "--> Running AWS post-deployment checks..."
          # Example: Check instance state using values from the generated variables artifact
          INSTANCE_NAME=$(yq e '.tags.Name' "${TFVARS_FILE}")
          aws ec2 describe-instances --filters "Name=tag:Name,Values=${INSTANCE_NAME}" --query "Reservations[].Instances[].State.Name"
          # Example: Notify via SNS using a topic ARN from Parameter Store
          # aws sns publish --topic-arn "${SNS_TOPIC_ARN}" --message "Deployment for ${INSTANCE_NAME} completed successfully."
        fi
      

artifacts:
  files:
    # Artifacts needed for subsequent stages or for auditing.
    # The base-directory ensures artifacts are stored with their directory structure,
    # which is crucial for the APPLY stage to find the tfplan file correctly.
    - 'tfplan'
    - 'plan.json'
  base-directory: '${COMPOSITION_PATH}'
  discard-paths: no

cache:
  paths:
    # Cache the custom directory where we install binaries.
    - '.local/bin/**/*'
    # Cache the pip package cache. The home directory in CodeBuild is /root.
    - '/root/.cache/pip/**/*'
    # Cache the npm package cache.
    - '/root/.npm/**/*'